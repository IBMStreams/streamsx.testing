#!/bin/bash

#some setup to be save
IFS=$' \t\n'
#some recomended security settings
unset -f unalias
\unalias -a
unset -f command
#more setting to be save
set -o posix;
set -o errexit; set -o errtrace; set -o nounset; set -o pipefail
shopt -s globstar nullglob

#------------------------------------------------------
# get the current directory and write it to currentDir
declare -r currentDir=$(pwd)

#------------------------------------------------------
#get the scripts path and write it into scriptsDir
#realpath is not available in rhel6
if [[ -h $0 ]]; then
	declare -r realCommand=$(readlink -e "$0")
	declare -r commandname="${realCommand##*/}"
	declare -r TTRO_scriptDir="${realCommand%/*}"
else
	tmp="${0%/*}"
	cd "$tmp"
	declare -r TTRO_scriptDir=$(pwd)
	cd "${currentDir}"
	declare -r commandname="${0##*/}"
fi

#---------------------------------------------------
#include the utils define the preliminary trace vars
source "${TTRO_scriptDir}/version.sh"
declare -x TTPN_debug=""
declare -x TTPN_debugDisable=""
declare -x TTPN_verbose=""
declare -x TTPN_verboseDisable=""

#-----------------------------------------------------
# Shutdown and interrut vars and functions
declare interruptReceived=""

# Function interruptSignalMain
function interruptSignalMain {
	echo "SIGINT received in $commandname ********************"
	if [[ -z $interruptReceived ]]; then
		interruptReceived="true"
	else
		echo "Abort test"
		exit $errSigint
	fi
	return 0
}

trap interruptSignalMain SIGINT

# Function errorExit
#	global error exit function - prints the caller stack
function errorExit {
	echo -e "\033[31mERROR: $FUNCNAME ***************"
	local -i i=0;
	while caller $i; do
		i=$((i+1))
	done
	echo -e "************************************************\033[0m"
}

trap errorExit ERR
#trap -p

#-----------------------------------------------------
#include the definitions
source "${TTRO_scriptDir}/defs.sh"
source "${TTRO_scriptDir}/mainutil.sh"
source "${TTRO_scriptDir}/util.sh"

#--------------------------------------------------------------------------------------
#The export check - checks whethere there are already vaiables exported with TT prefix
declare exportCheckFailed=""
for x in "${!TTRO_@}"; do
	if [[ $x != TTRO_scriptDir && $x != TTRO_tools && $x != TTRO_version && $x != TTRO_help* ]]; then
		exportCheckFailed="true"
		printWarning "In environment there are TT scoped identifier: ${x}"
	fi
done
for x in "${!TTPN_@}"; do
	if [[ $x != TTPN_debug && $x != TTPN_debugDisable && $x != TTPN_verbose && $x != TTPN_verboseDisable ]]; then
		exportCheckFailed="true"
		printWarning "In environment there are TT scoped identifier: ${x}"
	fi
done
for x in "${!TTP_@}"; do
	exportCheckFailed="true"
	printWarning "In environment there are TT scoped identifier: ${x}"
done
for x in "${!TT_@}"; do
	exportCheckFailed="true"
	printWarning "In environment there are TT scoped identifier: ${x}"
done

#------------------------------------------------------
#declare all options and option variables the key is also the variable name
declare -r -A singleOptions=(
	['verbose']='-v --verbose'
	['debug']='-d --debug'
	['noChecks']='-n --no-checks'
	['noStart']='--no-start'
	['noStop']='--no-stop'
	['reference']='--ref'
	['flat']='-f --flat'
	['noprompt']='--noprompt'
)
declare -r -A valueOptions=(
	['workdir']='-w --workdir'
	['directory']='-i --directory'
	['skipIgnore']='-s --skip-ignore'
	['properties']='-p --properties'
	['threads']='-j --threads'
)
for x in ${!singleOptions[@]}; do
	declare ${x}=""
done
for x in ${!valueOptions[@]}; do
	declare ${x}=""
done
declare toolsFiles="" #The with tools fies to include
declare -a varNamesToSet=() #The list with variable names to set
declare -a varValuesToSet=() #The list with variables values to set
declare -a cases=() # the list of cases from command line

#------------------------------------------------------
#set number of cores
declare -r noCpus=$(cat /proc/cpuinfo | grep processor | wc -l)
#getconf _NPROCESSORS_ONLN

#------------------------------------------------------
# get parametes and set option variables and cases map
declare parametersection="" # we start with options
while [[ $# -ge 1 ]]; do
  case $1 in
	-h|--help )
		[[ -z $parametersection ]] || optionInParamSection $1
		usage
		exit 0;;
	--man)
		[[ -z $parametersection ]] || optionInParamSection $1
		source "${TTRO_scriptDir}/man.sh"
		manpage
		exit 0;;
	--bashhelp)
		[[ -z $parametersection ]] || optionInParamSection $1
		source "${TTRO_scriptDir}/manbash.sh"
		manbashpage
		exit 0;;
	-V|--version)
		[[ -z $parametersection ]] || optionInParamSection $1
		echo "$TTRO_version"
		exit 0;;
#	-t|--tools)
#		[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
#		toolsFiles="$toolsFiles $2"
#		shift;;
	-D)
		[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
		vname=${2%%=*}
		vvalue={2#=*}
		if [[ $2 != $vname && $2 != $vvalue ]]; then
			i=${#varNamesToSet[@]}
			${varNamesToSet[$i]}="$vname"
			${varValuesToSet[$i]}="$vvalue"
			shift
		else
			printError "Invalid format in parameter -D $2 variable name=$vname variable value=$vvalue"
			usage
			exit ${errInvocation}
		fi;;
	-* )
		[[ -z $parametersection ]] || optionInParamSection $1
		declare optionFound=""
		for option in ${!singleOptions[@]}; do
			for ex in ${singleOptions[$option]}; do
				if [[ $1 == ${ex} ]]; then
					if [[ -n ${!option} ]]; then duplicateOption "${1}"; fi
					eval "${option}=true"
					optionFound="true"
					break 2
				fi
			done
		done
		if [[ -z ${optionFound} ]]; then
			for option in ${!valueOptions[@]}; do
				for ex in ${valueOptions[$option]}; do
					if [[ $1 == ${ex} ]]; then
						if [[ -n ${!option} ]]; then duplicateOption "${1}"; fi
						[[ $# -ge 2 && $2 != -* ]] || missOptionArg $1;
						eval "${option}=$2"
						optionFound="true"
						shift
						break 2
					fi
				done
			done
		fi
		if [[ -z ${optionFound} ]]; then
			printError "Invalid argument '$1' !!!\n\n"
			usage;
			exit ${errInvocation}
		fi
	;;
	* )
		parametersection="true"
		if [[ $1 == *::?* ]]; then
			n=${#cases[*]}
			cases[$n]="$1"
		else
			printErrorAndExit "Invalid format of test case '$1'.\nTest cases must be in the form suite::case or ::case" ${errInvocation}
		fi
	;;
	esac
	shift
done
unset -v parametersection

#--------------------------------------
# evaluate export check
#if [[ -n "$exportCheckFailed" ]]; then
#	exit ${errRt}
#fi
unset -v exportCheckFailed
#echo "*******************************************************************************************************"
echo  "**** START test case collection ***********************************************************************"
declare -x TTRO_reference=""
if [[ $reference == "true" ]]; then
	TTRO_reference="true"
fi
#---------------------------------------------------------
#set the number of threads to noCpus if not set otherwise
if [[ -z $threads ]]; then
	threads=$noCpus
fi

#---------------------------------------------------------
# create workdir if necessary and make it absolute
if [[ -z ${workdir} ]]; then
	workdir="${currentDir}/${DEFAULT_WORKDIR}"
fi
if ! mkdir -p ${workdir}; then
	printErrorAndExit "Can not create workdir '${workdir}'" ${errRt}
fi
if cd "${workdir}"; then
	workdir=$(pwd -P)
else
	printErrorAndExit "Invalid workdir '${workdir}' specified" ${errInvocation}
fi
cd "${currentDir}"
#---------------------------------------------------------
# get input directory and make it absolute
if [[ -z ${directory} ]]; then
	printErrorAndExit "No input directory specified" ${errInvocation}
else
	if cd "${directory}"; then
		directory=$(pwd -P)
		declare -x TTRO_inputDir="$directory"
	else
		printErrorAndExit "Invalid directory '${directory}' specified" ${errInvocation}
	fi
	cd "${currentDir}"
fi

#-------------------------------------
#properties file : if no path element is given use the input dir as prefix
if [[ -n  ${properties} ]]; then
	if [[ ( ${properties:1:1} != "/" ) && (${properties:1:1} != \. ) ]]; then
		properties=${directory}/${properties}
	fi
fi

#-------------------------------------
#tools file
#if ! declare -p TTRO_tools &> /dev/null; then
#	declare TTRO_tools=""
#fi
#for x in ${toolsFiles}; do
#	tmp="$x"
#	if [[ "${tmp:1:1}" != "/" ]]; then
#		tmp=${currentDir}/${tmp}
#	fi
#	TTRO_tools="$TTRO_tools $tmp"
#done

#----------------------------------
#finally make option variables read only
for x in ${!singleOptions[@]}; do
	readonly ${x}
done
for x in ${!valueOptions[@]}; do
	readonly ${x}
done

#-------------------------------------------
# set the global programm defined properties
TTPN_debug="$debug"
TTPN_verbose="$verbose"
declare -x TTRO_noParallelCases="$threads"
# declare -x TTRO_noCpus="$noCpus"
if [[ TTRO_noParallelCases -eq 1 ]]; then
	declare -x TTRO_treads="$noCpus"
else
	declare -x TTRO_treads=1
fi

#some more property definitions
for ((i=0; i<${#varNamesToSet[@]}; i++)); do
	declare "${varNamesToSet[$i]}"="${varValuesToSet[$i]}"
done
declare TTRO_noStart=""
declare TTRO_noStop=""
if [[ $noStart == "true" ]]; then
	TTRO_noStart="true"
fi
if [[ $noStop == "true" ]]; then
	TTRO_noStop="true"
fi
fixPropsVars

#--------------------------------
# Programm entry
printParams

#-----------------------------------------------------------------------------------------
# Check test collection files and properies file if properties parameter was given
tmp="$TTRO_inputDir/$TEST_COLLECTION_FILE"
if [[ -r "$tmp" ]]; then
	isVerbose && echo "Found radable test collection file $tmp"
else
	printErrorAndExit "No test collection file $tmp found" $errRt
fi
if [[ -n "$properties" ]]; then
	if [[ -r "$properties" ]]; then
		isVerbose && echo "Found radable test properties file $properties"
	else
		printErrorAndExit "No test properties file $properties found"
	fi
fi

#-----------------------------------------------------------------------------------------
# search test suites. Suites are directories with a suite definition file $TEST_SUITE_FILE
declare -A caseMap=() # The case map; key is the suite path; value is the case path list (space separated)
declare -i noSuites=0 # the global number of suites
if [[ -z $TTRO_reference ]]; then
	searchSuites
	if arrayHasKey "caseMap" "$TTRO_inputDir"; then
		printErrorAndExit "No $TEST_SUITE_FILE allowed in input dir $TTRO_inputDir" $errRt
	fi
#	isDebug && printDebug "Enter Dummy Suite ${TTRO_inputDir}"
#	caseMap["$TTRO_inputDir"]=''	#enter dummy suite
#	noSuites=$((noSuites+1))
fi
isDebug && printDebug "$noSuites suites found"
checkSuiteList # check nested suite and duplicate test suite names. This is considered an error
# print suites
if isDebug; then
	printDebug "******************* test suites found *******************"
	for x in ${!caseMap[@]}; do
		if [[ $TTRO_inputDir == $x ]]; then
			tmp='--'
		else
			tmp=${x##*/}
			if [[ $tmp == '--' ]]; then
				printErrorAndExit "Suite must not have name '--'" $errRt
			fi
		fi
		printDebug "${tmp}\t\t${x}"
	done
fi

#----------------------------------------------------------------------------------------------------
#search test cases. Cases are sub directories in suites with a case definition file $TEST_CASE_FILE
searchCases
# print cases
if isDebug; then
	printDebug "******************* test cases found *******************"
	for x in ${!caseMap[@]}; do
		if [[ $TTRO_inputDir == $x ]]; then
			tmp='--'
		else
			tmp=${x##*/}
		fi
		printDebug "Suite: $tmp"
		for y in ${caseMap["$x"]}; do
			printDebug "$y"
		done
	done
fi

#------------------------------------------
#The final list with test cases to execute
declare -A executionList=() # the cases to execute
declare    usedCaseIndexList='' # the list with the found cases
declare -i noCases=0
declare -a sortedSuites=()
#if the command line has no case list, all found cases are executed
#otherwise all matching cases found are executed
#if there is a case list on the command line, the skip attributes of test cases and suites are ignored
if [[ ${#cases[@]} -eq 0 ]]; then
	if [[ -n ${skipIgnore} ]]; then
		declare -rx TTRO_skipIgnore="true"
	else
		declare -rx TTRO_skipIgnore=""
	fi
	takeAllCases="true"
else
	declare -rx TTRO_skipIgnore="true"
	takeAllCases=""
fi

#-----------------------------------------
#sort suites alphabetical
isDebug && printDebug "****************** sort suites ***********************"
tmp=$( { for x in ${!caseMap[@]}; do echo "$x"; done } | sort )

sortedSuites+=( "${TTRO_inputDir}" ) # add dummy suite
for x in $tmp; do
	if [[ $x != $TTRO_inputDir ]]; then
		sortedSuites+=( "${x}" )
	fi
done
if isDebug; then
	printDebug "Sorted suites count=${#sortedSuites[@]}"
	for ((i=0; i<${#sortedSuites[@]}; i++)); do
		printDebug ${sortedSuites[$i]}
	done
fi

#------------------------------------------
#sort cases alphabetical
sortCases

#--------------------------------------------------
#check whether cases from input list are not found
for x in ${!cases[@]}; do
	patternMatchWasFound=''
	for y in $usedCaseIndexList; do
		if [[ $x == $y ]]; then
			patternMatchWasFound='true'
			break
		fi
	done
	if [[ -z $patternMatchWasFound ]]; then
		printWarning "Case ${cases[$x]} from parameter list was not found in input directory ${directory}"
	fi
done

#--------------------------------------------------
#guard the lists
readonly noCases executionList sortedSuites

#--------------------------------------------------
# print final execution list
if isVerbose; then
	echo "**** Collected Cases Summary: ${noCases} test cases to execute ****"
	for ((i=0; i<${#sortedSuites[@]}; i++)); do
		suitePath="${sortedSuites[$i]}"
		if [[ $suitePath == $TTRO_inputDir ]]; then
			suite='--'
		else
			suite=${suitePath##*/}
		fi
		echo "Suite: $suite path=$suitePath ----"
		for casePath in ${executionList[$suitePath]}; do
			case=${casePath##*/}
			echo -e "\tCase: $case path=${casePath}"
		 done
	done
	echo "********************************************************"
fi

#######################################################################################
#echo "*******************************************************************************************************"
echo  "**** START: Test execution ****************************************************************************"
#----------------
#make output dir
if [[ $flat == 'true' ]]; then
	TTRO_workDir="${workdir}"
else
	datestring=$(date +%Y%m%d-%H%M%S)
	TTRO_workDir="${workdir}/${datestring}"
fi
if [[ $flat != 'true' && -e $TTRO_workDir ]]; then
	printErrorAndExit "Output directory already exists $TTRO_workDir" $errRt
fi
if [[ -e $TTRO_workDir ]]; then
	if [[ $noprompt == "true" ]]; then
		rm -rf "$TTRO_workDir"
	else
		while read -p "ERROR: Output directory already exists $TTRO_workDir: Remove it or not or exit? y/n/e "; do
			if [[ $REPLY == "y" || $REPLY == "Y" ]]; then
				rm -rf "$TTRO_workDir"
				break
			elif [[ $REPLY == "n" || $REPLY == "N" ]]; then
				break
			elif [[ $REPLY == "e" || $REPLY == "E" ]]; then
				exit $errScript
			fi
		done
	fi
fi
mkdir -p "$TTRO_workDir"
echo "TTRO_workDir=$TTRO_workDir"
#{
#-----------------------------------------------------------
#check if properties file exists - read properties and fixup
if [[ -n $properties ]]; then
	isVerbose && echo "Include global properties $properties"
	setProperties "${properties}"
elif [[ -e "$TTRO_inputDir/$TEST_PROPERTIES" ]]; then
	isVerbose && echo "Include global properties $TTRO_inputDir/$TEST_PROPERTIES"
	setProperties "$TTRO_inputDir/$TEST_PROPERTIES"
else
	isVerbose && echo "No global properies file to evaluate"
fi
fixPropsVars # fix global properties and vars

#--------------------------------------
# Global includes
tmp="$TTRO_inputDir/$TEST_COLLECTION_FILE"
isVerbose && echo "Include global test tools $tmp"
setProperties "${tmp}"
fixPropsVars
source "$tmp"
fixPropsVars # fix global properties and vars
#if [[ -n $TTRO_tools ]]; then
#	for x in $TTRO_tools; do
#		isVerbose && echo "Source global tools file: $x"
#		if [[ -r $x ]]; then
#			setProperties "$x"
#			fixPropsVars # fix global properties and vars
#			source "$x"
#		else
#			printErrorAndExit "Tools file $x is required but this file is not readable" $errRt
#		fi
#	done
#else
#	isDebug && printDebug "No additional global test tools files defined"
#fi
#fixPropsVars # fix global properties and var

#------------------------------------------------
# enter working dir
cd "$TTRO_workDir"

#-----------------------------------------------
if [[ -n $TTRO_reference ]]; then
	list=$(echo "${!TTRO_help@} " | sort)
	{
		for x in $list; do
			echo "${!x}"
			echo
		done
	} | less
	exit 0
fi

#------------------------------------------------
# diagnostics
isVerbose && printTestframeEnvironment
printTestframeEnvironment > "${TTRO_workDir}/${TEST_ENVIRONMET_LOG}"
export >> "${TTRO_workDir}/${TEST_ENVIRONMET_LOG}"

#-----------------------------------
#prepare result files
for x in VARIANT SUCCESS SKIP FAILURE ERROR; do
	tmp=${TTRO_workDir}/${x}_LIST
	if [[ -e $tmp ]]; then
		printError "Global result list exists list: $tmp"
		rm -rf "$tmp"
	fi
	touch "$tmp"
done
tmp=${TTRO_workDir}/RESULT
if [[ -e $tmp ]]; then
	printError "Global result file exists list: $tmp"
	rm -rf "$tmp"
fi
touch "$tmp"

#-------------------------------------------------
# execute global test preparation
declare -i executedTestPrepSteps=0
declare result=0
if isExisting 'TTRO_testPrep'; then
	for x in $TTRO_testPrep; do
		isVerbose && echo "Execute global Test Preparation: $x"
		executedTestPrepSteps=$((executedTestPrepSteps+1))
		if eval "${x}"; then result=0; else result=$?; fi
		if [[ $result -ne 0 ]]; then
			printErrorAndExit "Execution of global Test Preparation: ${x} failed with return code=$result" $errRt
		fi
	done
fi
isVerbose && echo "$executedTestPrepSteps global Test Preparation steps executed"

#--------------------------------------------
#execution loop over suites and variants
declare -i suiteVariants=0
declare -i i j
for ((i=0; i<${#sortedSuites[@]}; i++)); do
	suitePath="${sortedSuites[$i]}"
	if [[ $suitePath == $TTRO_inputDir ]]; then
		suite='--'
	else
		suite="${suitePath##*/}"
	fi
	if [[ -n $interruptReceived ]]; then
		echo "SIGINT: end Suites loop"
		break
	fi
	isVerbose && echo "**** START Suite: $suite ************************************"
	variantCount=""; variantList=""; splitter=""
	if [[ $suite != '--' ]]; then
		readVariantFile "${suitePath}/${TEST_SUITE_FILE}" "suite"
	fi
	if [[ -z $variantCount ]]; then
		if [[ -z $variantList ]]; then
 			exeSuite "" "${TTRO_workDir}/${suite}" "$takeAllCases"
		else
			for x in $variantList; do
				exeSuite "$x" "${TTRO_workDir}/${suite}/${x}" "$takeAllCases"
			done
			unset x
		fi
	else
		if [[ -z $variantList ]]; then
			for ((j=0; j<variantCount; j++)); do
				exeSuite "$j" "${TTRO_workDir}/${suite}/${j}" "$takeAllCases"
			done
			unset j
		else
			printError "In suite $suite we have both variant variables variantCount=$variantCount and variantList=$variantList ! Suite is skipped"
		fi
	fi
	isVerbose && echo "**** END Suite: $suite **************************************"
	if [[ -n $interruptReceived ]]; then
		echo "SIGINT: end Suites loop"
		break
	fi
done
unset i

#-------------------------------------------------
# execute global test finalization
declare -i executedTestFinSteps=0
declare result=0
if isExisting 'TTRO_testFin'; then
	for x in $TTRO_testFin; do
		isVerbose && echo "Execute global Test Finalization: $x"
		executedTestFinSteps=$((executedTestFinSteps+1))
		if eval "${x}"; then result=0; else result=$?; fi
		if [[ $result -ne 0 ]]; then
			printError "Execution of global Test PFinalization: ${x} failed with return code=$result"
		fi
	done
fi
isVerbose && echo "$executedTestFinSteps global Test Finalization steps executed"

#print result lists
echo  "**** END Test execution *******************************************************************************"
for x in VARIANT SUCCESS SKIP FAILURE ERROR; do
	tmp="${TTRO_workDir}/${x}_LIST"
	eval "${x}Count=0"
	if isVerbose || [[ $x == 'FAILURE' || $x == 'ERROR' ]]; then echo "**** $x List : ****"; fi
	if [[ -e ${tmp} ]]; then
		{
			while read; do
				if isVerbose || [[ $x == 'FAILURE' || $x == 'ERROR' ]]; then echo "$REPLY "; fi
				eval "${x}Count=\$((\${x}Count+1))"
			done
		} < "$tmp"
	else
		printErrorAndExit "No result file ${tmp} exists" $errRt
	fi
done
#put results to results file for information purose only 
echo -e "STATE=completed\nVARIANT=$VARIANTCount\nSUCCESS=$SUCCESSCount\nSKIP=$SKIPCount\nFAILURE=$FAILURECount\nERROR=$ERRORCount" > "${TTRO_workDir}/RESULT"

echo
printf "*******************************************************************************************************\n"
printf "***** suite variants=%i\n" $suiteVariants
printf "***** case variants=%i skipped=%i failures=%i errors=%i\n" $VARIANTCount $SKIPCount $FAILURECount $ERRORCount
printf "***** used workdir: %s\n" "$TTRO_workDir"
printf "*******************************************************************************************************\n"

if [ $ERRORCount -gt 0 ]; then
	exit $errTestError
elif [ $FAILURECount -gt 0 ]; then
	exit $errTestFail
else
	exit 0
fi

#} 2>&1 | tee -i "${TTRO_workDir}/STDERROUT.log"
